# üñ•Ô∏è Backend Architecture

The backend uses **Express + TypeScript** and follows a **feature-driven, layered architecture** that is suitable for any project exposing a REST API and WebSocket events.

This structure maximizes **modularity**, **testability**, and **scalability**, allowing new features to be added without modifying unrelated parts of the codebase.

---

## üìÅ Global Folder Structure

```bash
/apps/backend
 ‚îú‚îÄ‚îÄ src/
 ‚îÇ   ‚îú‚îÄ‚îÄ config/               # Global configuration & environment handling
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ env.ts            # Loads & validates .env variables
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ db.ts             # Database connection pool setup
 ‚îÇ   ‚îÇ
 ‚îÇ   ‚îú‚îÄ‚îÄ core/                 # Global middlewares, error handling, base classes
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.ts            # Express app setup (middleware, routes)
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ server.ts         # Entry point, starts HTTP + WebSocket server
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares/      # Global middlewares (auth, error, validation)
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sockets.ts        # WebSocket server bootstrap
 ‚îÇ   ‚îÇ
 ‚îÇ   ‚îú‚îÄ‚îÄ features/             # Feature-based modules (one folder per feature)
 ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ example-feature/  # Example feature folder (see below)
 ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
 ‚îÇ   ‚îÇ
 ‚îÇ   ‚îú‚îÄ‚îÄ utils/                # Reusable helpers (hashing, token, logger, etc.)
 ‚îÇ   ‚îî‚îÄ‚îÄ types/                # Backend-only types & interfaces
 ‚îÇ
 ‚îú‚îÄ‚îÄ package.json
 ‚îî‚îÄ‚îÄ tsconfig.json
```

---

## üß© Feature Folder Structure

Each **feature** lives in its own folder inside `src/features/`.  
A feature can represent **any business domain**: `auth`, `users`, `chat`, `notifications`, `products`, etc.

Example:

```bash
/src/features/example-feature
 ‚îú‚îÄ‚îÄ example.routes.ts         # REST API endpoints for this feature
 ‚îú‚îÄ‚îÄ example.controller.ts     # Handles HTTP requests, calls service layer
 ‚îú‚îÄ‚îÄ example.service.ts        # Business logic, independent from Express
 ‚îú‚îÄ‚îÄ example.repository.ts     # Database queries (manual SQL)
 ‚îú‚îÄ‚îÄ example.socket.ts         # WebSocket event handlers for this feature
 ‚îú‚îÄ‚îÄ example.types.ts          # Feature-specific types/interfaces
 ‚îî‚îÄ‚îÄ index.ts                  # Exports everything for easy import
```

---

## üîë Layered Responsibilities

Each feature contains the same **4‚Äì5 layers**, following strict separation of concerns:

```mermaid
flowchart TD
    R[Routes] --> C[Controllers]
    C --> S[Services]
    S --> Repo[Repositories]
    Repo --> DB[(Database)]
    S --> Sock[Sockets]:::ws
    classDef ws fill=#ffe9b3,stroke=#d4a017,stroke-width=1px;
```

**Routes:**
- Define API endpoints (method + path)
- Attach middlewares (auth, validation)
- No business logic

**Controllers:**
- Translate HTTP requests into service calls
- Return standardized HTTP responses
- No DB or business logic

**Services:**
- Contain all business logic
- Reuse repositories for data access
- Throw typed errors (handled globally)

**Repositories:**
- Perform SQL queries (CRUD + custom queries)
- Return plain data objects (no HTTP awareness)

**Sockets (optional):**
- Define event listeners & emitters
- Use the same services as controllers to keep logic DRY

---

## üìê Modularity & Extensibility

- **Feature Encapsulation:** Each feature owns its routes, controllers, services, repositories, and socket handlers. Adding a new feature only means adding a new folder and registering its routes/socket namespace.
- **Dependency Injection:** Services receive repositories as constructor parameters, making them swappable or mockable.
- **Shared Types:** Use `/packages/shared` for types shared between backend and frontend. Keep backend-only types in `example.types.ts` (e.g., internal DB row structure).
- **Global Middleware:** Shared middlewares (auth, validation, error handler) are stored in `/core/middlewares` and automatically applied to routes where needed.

---

## üß© Naming Conventions

- **Feature Folders:** Named after the domain (`auth`, `users`, `chat`, etc.)
- **Files:** `<feature>.<layer>.ts` (e.g., `chat.service.ts`, `user.repository.ts`)
- **Exports:** Each feature has an `index.ts` that exports its route(s), controller(s), service(s), and socket(s)

---

## üöÄ Benefits of This Architecture

- **Feature-driven:** New features are self-contained ‚Üí minimal risk of regressions
- **Highly reusable:** Architecture works for any REST + WebSocket project
- **Scalable:** Easy to add more features, new transports (GraphQL, gRPC), or swap DB layer
- **Consistent:** Every feature follows the same structure ‚Üí no guessing where logic lives
- **Future-proof:** Mobile apps, microservices, or additional clients can reuse the same services