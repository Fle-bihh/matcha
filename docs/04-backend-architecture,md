# ğŸ–§ Backend Architecture

The backend uses **Express + TypeScript** and follows a **feature-driven, layered architecture** that is suitable for any project exposing a REST API and WebSocket events.

This structure maximizes **modularity, testability, and scalability**, allowing new features to be added without modifying unrelated parts of the codebase.

---

## ğŸ“ Global Folder Structure

```plaintext
apps/backend
 â”œâ”€â”€ src/
 â”‚   â”œâ”€â”€ api/              # Routes + controllers grouped by feature
 â”‚   â”‚   â””â”€â”€ users/
 â”‚   â”‚       â”œâ”€â”€ users.controller.ts
 â”‚   â”‚       â”œâ”€â”€ users.routes.ts
 â”‚   â”‚       â””â”€â”€ users.validators.ts
 â”‚   â”‚
 â”‚   â”œâ”€â”€ services/         # Business logic (feature-specific)
 â”‚   â”‚   â””â”€â”€ users.service.ts
 â”‚   â”‚
 â”‚   â”œâ”€â”€ repositories/     # Data access layer (manual SQL queries)
 â”‚   â”‚   â””â”€â”€ users.repo.ts
 â”‚   â”‚
 â”‚   â”œâ”€â”€ sockets/          # WebSocket event handlers (chat, notifications)
 â”‚   â”‚   â””â”€â”€ chat.socket.ts
 â”‚   â”‚
 â”‚   â”œâ”€â”€ middlewares/      # Express middlewares (auth, error handling, logging)
 â”‚   â”œâ”€â”€ utils/            # Helper functions, shared libs
 â”‚   â”œâ”€â”€ config/           # Env vars loading, DB connection, global constants
 â”‚   â”œâ”€â”€ types/            # Backend-specific types
 â”‚   â””â”€â”€ app.ts            # Express app setup (routes, middlewares)
 â”‚
 â”œâ”€â”€ tests/                # Unit/integration tests (Jest or similar)
 â”œâ”€â”€ package.json
 â””â”€â”€ tsconfig.json
```

---

## ğŸ›ï¸ Layered Architecture Principles

### 1ï¸âƒ£ Controllers (API Layer)
- Receive HTTP requests, validate input, and call the corresponding service.
- Return formatted HTTP responses (JSON).

### 2ï¸âƒ£ Services (Business Logic Layer)
- Contain business rules (e.g., match suggestions, fame rating calculation).
- Call repositories for data access.
- Can be unit tested in isolation.

### 3ï¸âƒ£ Repositories (Data Access Layer)
- Directly interact with the database using manual SQL queries.
- Return raw or shaped data objects.

This separation ensures that changing the database implementation (e.g., switching to PostgreSQL) does not affect controllers or services.

---

## ğŸ”„ Request Lifecycle (Example)

1. **Route receives request:** `POST /users/login`
2. **Validation:** Input validated with `zod` or `yup`
3. **Controller:** Calls `authService.login()`
4. **Service:** Checks password, generates JWT
5. **Repository:** Reads user from DB
6. **Response:** Returns `{ token, user }` to the client

---

## ğŸ“¡ WebSocket Events

WebSocket handlers live in `/sockets`.  
They follow a similar layered approach:

- **Socket Handler:** Listens for events, validates payload
- **Service:** Processes the event (e.g., save message, notify recipient)
- **Emit:** Sends event to specific rooms or users

Example: `chat.socket.ts` listens to `message:send` and emits `message:received`.

---

## ğŸ§ª Testing Strategy

- **Unit tests:** For services and utils (no DB connection required)
- **Integration tests:** For controllers and repositories (using a test DB)
- **Socket tests:** Simulate client-server events to ensure correct behavior

This architecture is **test-friendly**, enabling CI/CD pipelines to catch regressions early.